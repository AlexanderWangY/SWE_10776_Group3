from fastapi import APIRouter, Depends, Query, HTTPException, UploadFile, Form, File
import shutil
from pathlib import Path
from app.db.database import get_async_session
from typing import Annotated, Optional
from app.models.listing import Listing, ListingCategory, ListingCondition, ListingStatus
from app.schemas.listing import UserListingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, asc, desc, func
from sqlalchemy.orm import selectinload
from app.models.user import User
from app.auth.backend import fastapi_users
from app.schemas.pagination import Pagination, SortEnum, pagination_params

router = APIRouter()

# The below lines of code were generated by Copilot to debug why the image wasn't being saved to the correct directory
BASE_DIR = Path(__file__).resolve().parents[2]  # points to server/
LISTINGS_DIR = BASE_DIR / "app" / "static" / "images" / "listings"

# Source for utility function: https://stackoverflow.com/questions/63580229/how-to-save-uploadfile-in-fastapi
def save_upload_file(upload_file: UploadFile) -> None:
    try:
        with open(f"{LISTINGS_DIR}/{upload_file.filename}", "wb") as buffer:
            shutil.copyfileobj(upload_file.file, buffer)
    finally:
        upload_file.file.close()

async def get_listings(
    # in query parameters, specify page_num to indicate the page number and card_num to indicate the number of cards for pagination
    pagination: Annotated[Pagination, Depends(pagination_params)],
    async_session: AsyncSession = Depends(get_async_session),
    sort_by: Optional[str] = Query("updated_at", description="Sort field: price, created_at, updated_at"),
    order: Optional[str] = Query(SortEnum.DESC.value, description="Sort order: asc or desc"),

    # Filters
    status: Optional[str] = Query(None, description="Status value (matching ListingStatus enum)"),
    category: Optional[str] = Query(None, description="Category value (matching ListingCategory enum)"),
    condition: Optional[str] = Query(None, description="Condition value (matching ListingCondition enum)"),
    min_price: Optional[int] = Query(None, ge=0),
    max_price: Optional[int] = Query(None, ge=0),
    keyword: Optional[str] = Query(None, description="Keyword to search in title or description")
):
    sort_fields = {
        "id": Listing.title,
        "price": Listing.price_cents,
        "created_at": Listing.created_at,
        "updated_at": Listing.updated_at,
    }

    sort_column = sort_fields.get(sort_by, Listing.updated_at)
    sort_order = order.lower()

    if sort_by and sort_by not in sort_fields:
        raise HTTPException(status_code=400, detail=f"Invalid sort_by value '{sort_by}'. Must be 'price', 'created_at', or 'updated_at'.")

    if sort_order not in SortEnum:
        raise HTTPException(status_code=400, detail="Invalid order value. Must be 'asc' or 'desc'.")
    
    async with async_session as session:
        statement = select(Listing).options(selectinload(Listing.seller))

        if status:
            try:
                status_enum = ListingStatus[status.upper()]
            except KeyError:
                raise HTTPException(status_code=400, detail=f"Invalid status value '{status}'.")
            statement = statement.where(Listing.status == status_enum)

        if category:
            try:
                category_enum = ListingCategory[category.upper()]
            except KeyError:
                raise HTTPException(status_code=400, detail=f"Invalid category value '{category}'.")
            statement = statement.where(Listing.category == category_enum)

        if condition:
            try:
                condition_enum = ListingCondition[condition.upper()]
            except KeyError:
                raise HTTPException(status_code=400, detail=f"Invalid condition value '{condition}'.")
            statement = statement.where(Listing.condition == condition_enum)

        if min_price is not None:
            statement = statement.where(Listing.price_cents >= min_price)

        if max_price is not None:
            statement = statement.where(Listing.price_cents <= max_price)

        if keyword:
            search_filter = f"%{keyword}%"
            # Source: https://stackoverflow.com/questions/20363836/postgresql-ilike-query-with-sqlalchemy
            # Source: https://stackoverflow.com/questions/7942547/using-or-in-sqlalchemy
            statement = statement.filter(Listing.title.ilike(search_filter) | Listing.description.ilike(search_filter))

        statement = (
            statement.limit(pagination.card_num)
            .offset(
                pagination.page_num - 1
                if pagination.page_num == 1
                else (pagination.page_num - 1) * pagination.card_num
            )
            .order_by(asc(sort_column) if sort_order == SortEnum.ASC.value else desc(sort_column))
        )

        result = await session.scalars(statement)
        listings = result.all()
        return listings
    
@router.get("/listings/total", tags=["listings"])
async def get_total_listings(
    async_session: AsyncSession = Depends(get_async_session)
):
    """
    The purpose of this route is to get the total number of listings in the database
    for pagination.
    """
    async with async_session as session:
        total = await session.scalar(select(func.count(Listing.id)))
        return {"total": total}

@router.get("/listings/{listing_id}", tags=["listings"], response_model=UserListingResponse)
async def get_listing_by_id(
    listing_id: int,
    async_session: AsyncSession = Depends(get_async_session)
):
    """
    The purpose of this route is to retrieve a listing by its ID.
    """
    async with async_session as session:
        statement = (
            select(Listing)
            .options(selectinload(Listing.seller))
            .where(Listing.id == listing_id)
        )
        result = await session.scalars(statement)
        listing = result.one()
        return listing

# Pagination tutorial: https://www.youtube.com/watch?v=Em6OzzcO9Xo
# https://stackoverflow.com/questions/74941021/using-sqlalchemy-what-is-a-good-way-to-load-related-object-that-are-were-not-ea
@router.get("/listings", tags=["listings"], response_model=list[UserListingResponse])
async def get_listings_standard(
    # in query parameters, specify page_num to indicate the page number and card_num to indicate the number of cards for pagination
    pagination: Annotated[Pagination, Depends(pagination_params)],
    async_session: AsyncSession = Depends(get_async_session),
    sort_by: Optional[str] = Query("updated_at", description="Sort field: price, created_at, updated_at"),
    order: Optional[str] = Query(SortEnum.DESC.value, description="Sort order: asc or desc"),

    # Filters
    status: Optional[str] = Query(None, description="Status value (matching ListingStatus enum)"),
    category: Optional[str] = Query(None, description="Category value (matching ListingCategory enum)"),
    condition: Optional[str] = Query(None, description="Condition value (matching ListingCondition enum)"),
    min_price: Optional[int] = Query(None, ge=0),
    max_price: Optional[int] = Query(None, ge=0),
    keyword: Optional[str] = Query(None, description="Keyword to search in title or description")

):
    """
    The below return statement was autocompleted by Copilot to assist with 
    calling the get_listings core function from the respective endpoints. It is a pretty self-explanatory return statement, 
    but using Copilot made it go faster.
    """
    return await get_listings(
        pagination=pagination,
        async_session=async_session,
        sort_by=sort_by,
        order=order,
        status=status,
        category=category,
        condition=condition,
        min_price=min_price,
        max_price=max_price,
        keyword=keyword
    )

@router.post("/listings/new", tags=["listings"], response_model=UserListingResponse)
async def create_listing(
    title: Annotated[str, Form(...)],
    description: Annotated[str, Form(...)],
    price: Annotated[str, Form(...)],
    # the below three parameters were debugged by Copilot, since formData objects require Form(...) and File(...) fields even when it is nullable
    # not having these default Form() values was causing 422 unprocessable errors.
    category: ListingCategory | None = Form(None),
    condition: ListingCondition | None = Form(None),
    image: UploadFile | None = File(None),
    async_session: AsyncSession = Depends(get_async_session),
    user = Depends(fastapi_users.current_user())
):
    if image:
        save_upload_file(image)
    # Create a new Listing object and add it to the database
    # Source: https://medium.com/@halpertln/session-queries-in-sqlalchemy-90233d455b12
    async with async_session as session:
        new_listing = Listing(
            title=title,
            seller_id=user.id,
            description=description,
            price_cents=int(price) * 100,
            status=ListingStatus.ACTIVE,
            category=category,
            condition=condition,
            image=f"images/listings/{image.filename}" if image else None
        )
        session.add(new_listing)
        await session.commit()
        # Verify that the listing exists in the database and return the new listing
        statement = (
            select(Listing)
            .options(selectinload(Listing.seller))
            .where(Listing.id == new_listing.id)
        )
        result = await session.scalars(statement)
        listing = result.one()
        return listing